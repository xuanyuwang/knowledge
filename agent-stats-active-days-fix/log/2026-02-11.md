# Project Log - 2026-02-11

## Progress

- Investigated second CSM report: Corinne Harmon shows 0 active days on 2/10 for the "chat" use case
- Root cause: `conversation_with_labels_d` not re-labeled after conversation re-assignment
- This is a NEW issue distinct from the FULL OUTER JOIN fix (PR #25613)

## Details

### CSM Report

"Corinne Harmon on 2/10 shows a 0 on Leaderboard, but all chats in CC were processed in Real Time. I would have expected this agent to show a 1. I see the agent didn't take their first chat until 6:33pmMT but Leaderboard does look 'wrong' currently."

### Investigation

- Agent: Corinne Harmon (`256f70253da263fe`)
- Customer: Alaska Air
- API request filters: `usecaseNames=chat`, `timeZoneId=America/Toronto` (EST), date range `2026-02-10T05:00:00Z` to `2026-02-11T04:59:59.999Z`
- API response: all zeros (`totalAgentLoginCount=0, activeAgentCount=0`)

### Root Cause: Stale `conversation_with_labels_d` After Conversation Re-assignment

17 conversations were created on 2/10 evening (starting 01:33 UTC on 2/11):

1. **01:33 UTC**: Conversations created with various original agents in `reservations-chat` use case
2. **02:00 UTC**: `cron-label-conversations` runs, writes to `conversation_with_labels_d` with the original agent_user_ids and `usecase_id=reservations-chat`
3. **03:01 UTC**: Conversations updated in `conversation_d` — agent changed to Corinne Harmon, usecase changed to `chat`
4. `conversation_with_labels_d` **never re-labeled** — still has original agents + `reservations-chat`

When the Leaderboard queries `usecase_id='chat'` for Corinne:
- `convs` CTE (conversation_d): 17 matches → total_agent_count = 1
- `convs_with_aa` CTE (conversation_with_labels_d): 0 matches for Corinne+chat → active_agent_count = 0
- With `useCrestaConversationWithAACount=true`: all metrics = activeAgentCount = 0
- Leaderboard shows "0"

### Why the CSM Sees "First Chat at 6:33pm MT"

Corinne had 77 total conversations on 2/10:
- 58 conversations: `usecase_id=customer-care` (voice, channel 2), starting 9:30 AM MT
- 17 conversations: `usecase_id=chat`, starting 6:33 PM MT
- 2 conversations: `usecase_id=reservations-chat`

The CSM was viewing the Leaderboard filtered to the `chat` use case, so only the 17 chat conversations were visible (first at 6:33pm MT).

### Data Evidence

**conversation_d** (final state, updated at ~03:01 UTC):
```
conversation_id: 019c4a55-3b3d-a855-ba8f-1cf13cae4b6a
agent_user_id: 256f70253da263fe (Corinne Harmon)
usecase_id: chat
update_time: 2026-02-11 03:01:19
```

**conversation_with_labels_d** (labeled at ~02:00 UTC, never re-labeled):
```
conversation_id: 019c4a55-3b3d-a855-ba8f-1cf13cae4b6a
agent_user_id: 9f87ef86708a74fc (different agent)
usecase_id: reservations-chat
update_time: 2026-02-11 02:00:10
```

All 17 "chat" conversations show the same pattern: different agent + different usecase in `conversation_with_labels_d` vs `conversation_d`.

### Cron Job Analysis

**Code**: `go-servers/cron/sync-users/internal/conversation-agent-assistance/task.go`

**Current time range logic** (`setTimeRange`):
- Start: `SELECT max(conversation_start_time) FROM conversation_with_labels_d` (latest labeled conversation)
- End: `time.Now()`
- Only processes NEW conversations — never revisits previously labeled ones

**Key detail**: The cron does NOT filter by closed conversations. It processes all conversations in the `created_at` range, including still-open ones. This is how it labeled the 17 conversations at 02:00 UTC while they were still assigned to the original agents — before re-assignment at 03:01 UTC.

**ClickHouse table engine**: `ReplicatedReplacingMergeTree` with `update_time` as version column. ORDER BY includes `agent_user_id`, so re-writing a conversation with a different agent creates a NEW row instead of replacing the old one.

### Proposed Fix Options

All options require **delete-before-write** because the `conversation_with_labels` table uses `ReplicatedReplacingMergeTree` with ORDER BY `(toStartOfHour(conversation_end_time), agent_user_id, conversation_id, customer_id, profile_id)`. Since `agent_user_id` and `toStartOfHour(conversation_end_time)` are in the ORDER BY key, re-writing a conversation with changed agent/end_time creates a NEW row instead of replacing. Delete existing rows for those `conversation_id`s before writing to ensure clean replacement.

#### Option A: Lookback Window + Delete-Before-Write

Extend the cron's lookback window to re-process recent conversations:

1. **Change `setTimeRange`**: Start from `max(conversation_start_time) - 2 hours` instead of `max(conversation_start_time)`
2. **Delete before write**: Delete existing rows for those `conversation_id`s before writing the re-labeled batch

**Trade-offs**:
- Modest increase in processing load (~4x re-processing per conversation in the lookback window)
- 2-hour window covers the observed re-assignment delay (~1.5 hours in Corinne's case); could increase to 3-4 hours for safety
- Won't catch re-assignments that happen after the lookback window, but these should be rare

#### Option B: Filter by `ended_at` + Delete-Before-Write

Change the cron to only process closed conversations by filtering on `ended_at` instead of `created_at`:

```go
// Current (line 311):
Where("chats.created_at >= ? AND chats.created_at < ?", startTime, endTime)
// Proposed:
Where("chats.ended_at >= ? AND chats.ended_at < ?", startTime, endTime).
Where("chats.ended_at IS NOT NULL")
```

This addresses the root cause more directly — conversations are only labeled after close, when re-assignments are typically complete. Also need to adjust `setTimeRange` to derive start from `max(conversation_end_time)` or `max(update_time)` instead of `max(conversation_start_time)`.

Still needs delete-before-write because `ended_at` itself can be updated after re-assignment (changing `toStartOfHour(conversation_end_time)` in the ORDER BY key).

**Trade-offs**:
- Cleaner than lookback — labels final state rather than re-labeling
- Long-running conversations get labeled later (only after close), acceptable for a daily metric
- Conversations that never close (`ended_at IS NULL`) are never labeled — arguably correct

#### Option C: Change ORDER BY to Remove Mutable Columns

Change the table ORDER BY to remove columns that can change after re-assignment:

```sql
-- Current:
ORDER BY (toStartOfHour(conversation_end_time), agent_user_id, conversation_id, customer_id, profile_id)
-- Proposed:
ORDER BY (conversation_id, customer_id, profile_id)
```

This makes ReplacingMergeTree deduplicate on `conversation_id` alone, so re-writes with different agent/usecase/end_time correctly replace the old row. No delete-before-write needed.

**Performance impact**: The current PRIMARY KEY `(toStartOfHour(conversation_end_time), agent_user_id)` does **NOT** benefit the agent stats query — that query filters and groups by `conversation_start_time`, not `conversation_end_time`. Neither column in the current key matches the query's access pattern. So removing them has zero impact on the agent stats query.

The impact would be on other queries (if any) that filter by `conversation_end_time` or `agent_user_id` on this table. Since each customer has their own ClickHouse database, table sizes are bounded per customer and ClickHouse handles column scans efficiently.

**Trade-off**: Requires a schema migration across all customer databases.

#### Recommended Approach

Option B (filter by `ended_at`) + delete-before-write. Optionally combine with Option C (schema change) to eliminate the need for delete-before-write long-term.

### Distinction from Previous Bug (Feb 9)

| Aspect | Feb 9 Bug (PR #25613) | Feb 11 Bug (this) |
|--------|----------------------|-------------------|
| Symptom | N/A instead of 0 | 0 instead of 1 |
| Root cause | LEFT JOIN drops rows when convs CTE has no data | conversation_with_labels_d has stale agent/usecase |
| Trigger | exclude_ingestion_pipeline flag + source 8 only | Conversation re-assignment after cron labeling |
| Fix | FULL OUTER JOIN + COALESCE + Go guard | Lookback window + delete-before-write in cron |
